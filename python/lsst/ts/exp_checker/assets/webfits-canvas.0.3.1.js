// Generated by CoffeeScript 1.4.0
// ADW: Comes from https://github.com/astrojs/rawimage.js
(function() {
  var Api, BaseApi, WebFITS, version,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (this.astro == null) {
    this.astro = {};
  }

  WebFITS = {};

  WebFITS.version = '0.3.1';

  this.astro.WebFITS = WebFITS;

  BaseApi = (function() {

    function BaseApi(el, width, height) {
      var canvasStyle, overlayStyle, parentStyle;
      this.el = el;
      this.wheelHandler = __bind(this.wheelHandler, this);

      this._reset();
      this.width = width;
      this.height = height;
      this.canvas = document.createElement('canvas');
      this.canvas.setAttribute('width', this.width);
      this.canvas.setAttribute('height', this.height);
      this.canvas.setAttribute('class', 'visualization');
      this.overlay = document.createElement('canvas');
      this.overlay.setAttribute('width', this.width);
      this.overlay.setAttribute('height', this.height);
      this.overlay.setAttribute('class', 'overlay');
      this.overlayCtx = this.overlay.getContext('2d');
      this.report = document.createElement('canvas');
      this.report.setAttribute('width', this.width);
      this.report.setAttribute('height', this.height);
      this.report.setAttribute('class', 'report');
      this.reportCtx = this.report.getContext('2d');
      this.el.appendChild(this.canvas);
      this.el.appendChild(this.overlay);
      this.el.appendChild(this.report);
      this.nImages = 0;
	this.rescaling = 1.;	
      if (!this.getContext()) {
        return null;
      }
      this.offsetLeft = this.canvas.offsetLeft;
      this.offsetTop = this.canvas.offsetTop;
      //ADW: Don't show mask by default
      //this.showMask = true;
      this.showMask = false;
      parentStyle = this.canvas.parentElement.style;
      parentStyle.width = "" + this.canvas.width + "px";
      parentStyle.height = "" + this.canvas.height + "px";
      parentStyle.overflow = 'hidden';
      parentStyle.backgroundColor = '#252525';
      parentStyle.position = 'relative';
      canvasStyle = this.canvas.style;
      overlayStyle = this.overlay.style;
      reportStyle = this.report.style;
      canvasStyle.position = 'absolute';
      overlayStyle.position = 'absolute';
      reportStyle.position = 'absolute';
      overlayStyle.pointerEvents = 'none';
      reportStyle.pointerEvents = 'none';
    }

    BaseApi.prototype.setupControls = function(callbacks, opts) {
      var _onmousedown, _onmousemove, _onmouseout, _onmouseover, _onmouseup,
        _this = this;
      if (callbacks == null) {
        callbacks = null;
      }
      if (opts == null) {
        opts = null;
      }
      
      if ((callbacks != null ? callbacks.onclick : void 0) != null) {
        this.canvas.onclick = function(e) {
          return callbacks.onclick.call(_this, _this, opts, e);
        };
      }
    };
    
    return BaseApi;

  })();

  this.astro.WebFITS.BaseApi = BaseApi;

  BaseApi = this.astro.WebFITS.BaseApi;

  Api = (function(_super) {

    __extends(Api, _super);

    function Api() {
      return Api.__super__.constructor.apply(this, arguments);
    }

    Api.prototype._reset = function() {
      this.images = {};
      this.scales = {};
      return this.calibrations = {};
    };

    Api.prototype._applyTransforms = function() {
      var transforms;
      transforms = ["scaleX(" + this.zoom + ")", "scaleY(" + (this.zoom) + ")", "translateX(" + this.xOffset + "px)", "translateY(" + this.yOffset + "px)"].join(' ');
      this.canvas.style.transform = transforms;
      this.canvas.style.webkitTransform = transforms;
      return this.canvas.style.MozTransform = transforms;
    };

    Api.prototype.getContext = function() {
      this.ctx = this.canvas.getContext('2d');
      this.draw = this.drawPeter;
      return this.ctx;
    };

    Api.prototype.setupControls = function() {
      var _this = this;
      Api.__super__.setupControls.apply(this, arguments);
    };

    Api.prototype.loadImage = function(identifier, arr, width, height) {
      // document.write("loadImage"+",");
      // document.write("width = "+width+",");
      // document.write("height = "+height+",");
      // document.write("arr.length = "+arr.length+",");
      // document.write("identifier = "+identifier+",");
      this.images[identifier] = {
        arr: new Float32Array(arr),
        width: width,
        height: height
      };
      if (!this.currentImage) {
        this.setImage(identifier);
      } 
      return this.nImages += 1;
    };

    Api.prototype.setImage = function(identifier) {
      return this.currentImage = identifier;
    };

    Api.prototype.setStretch = function(stretch) {
      switch (stretch) {
        case 'arcsinh':
          this.draw = this.drawAsinh;
          break;
        case 'peter':
          this.draw = this.drawPeter;
          break;
        default:
          this.draw = this.drawPeter;
      }
      return this.draw();
    };

    Api.prototype.setExtent = function(min, max) {
      this.minimum = min;
      this.maximum = max;
      return this.draw();
    };

    Api.prototype.setRescaling = function(value) {
      this.rescaling = value;
      return this.draw();	
    };
      
    Api.prototype.setScales = function(r, g, b) {
      // document.write("setScales,");
      this.scales.r = r;
      this.scales.g = g;
      this.scales.b = b;
      return this.draw();
    };

    Api.prototype.setCalibrations = function(r, g, b) {
      this.calibrations.r = r;
      this.calibrations.g = g;
      this.calibrations.b = b;
      return this.draw();
    };

    Api.prototype.setAlpha = function(value) {
      this.alpha = value;
      return this.draw();
    };

    Api.prototype.setQ = function(value) {
      this.Q = value;
      return this.draw();
    };

    // color all masked pixels blue
    Api.prototype.addMask = function(arr) {
      var data = this.images.bpm.arr;
      var length = arr.length;
      var value, bitValue, color;

      //https://github.com/LSSTDESC/desc-exp-checker/issues/25
      var maskPlaneDict = [
	  //[5, [0, 0, 255]],   // DETECTED (blue)
	  //[6, [0, 255, 255]], // DETECTED_NEGATIVE (cyan)
	  [2, [0, 255, 0]],     // INTRP (green)
	  [8, [255, 165, 0]],   // NO_DATA (orange)
          [1, [0, 255, 0]],     // SAT (green)
	  [4, [255, 255, 0]],   // EDGE (yellow)
	  [3, [255, 0, 255]],   // CR (magenta)
          [0, [255, 0, 0]],     // BAD (red)
	  //[7, [255, 255, 0]], // SUSPECT (yellow)
      ];

      while (length -= 4) {
        value = data[length / 4];
        if (value % 32768 != 0) { // issue with fits.js, compression and Uint16
          value = value % 32768;
          for (var i=0; i < maskPlaneDict.length; i++) { 
	    bitValue = 2**maskPlaneDict[i][0];
	    color = maskPlaneDict[i][1];
	    if ((value & bitValue) == bitValue) {
	      arr[length + 0] = color[0];
	      arr[length + 1] = color[1];
	      arr[length + 2] = color[2];
	    }
	  }
          //arr[length + 0] = 0;
          //arr[length + 1] = 0;
          //arr[length + 2] = 255;
        }
      }
    };

    Api.prototype.median = function(arr) {
        // Subtract the median from an array in place.
        var i = 0;
        var len = arr.length;
        var data = arr.slice();
        data.sort();
        var med = data[len/2];
        for (i = 0; i < len; i++){
          arr[i] -= med
        };
    };

    Api.prototype.flipYAxis = function(arr,width,height) {
        // Flips the y-axis of an input array in place.
        // Loops through top half of image and switches rows.
        // Note that 'arr' has 4 entries per value [r,g,b,alpha]

        //console.log("Flipping Y-Axis...");
        var i, j;
        var idx1,idx2,tmp;

        // Only need to loop over first half of image
        for (i = 0; i < height/2; i++){
            for (j = 0; j < width; j++){
                idx1 = width*i + j;
                idx2 = width*(height - i) + j;
                tmp = arr[idx1];
                arr[idx1] = arr[idx2];
                arr[idx2] = tmp;
            };
        };
    };

    Api.prototype.flipCanvas = function() {
      // This function flips the canvas y-axis orientation *after* the
      // image data has been drawn. The drawback of this method is
      // that the image is drawn twice.
      // https://stackoverflow.com/a/47404427
      console.log("Flipping canvas...");

      // flip the canvas
      this.ctx.transform(1, 0, 0, -1, 0, this.height)

      // if you have transparent pixels
      this.ctx.globalCompositeOperation = "copy"; 
      this.ctx.drawImage(this.ctx.canvas,0,0);
      this.ctx.globalCompositeOperation = "source-over"; // reset to default
    };

    Api.prototype.drawAsinh = function(minval) {
      // This function is poorly constructed. It packages the
      // infrastructure to draw the image to the canvas with the asinh
      // scaling. It would be best to separate these, but currently
      // combined for speed (avoids two loops).

      // console.log("drawAsinh,");
      var arr, data, height, imgData, length, max, min, pixel, range, value, width;
      data = this.images[this.currentImage].arr;
      width = this.images[this.currentImage].width;
      height = this.images[this.currentImage].height;
      this.median(data);
      imgData = this.ctx.getImageData(0, 0, width, height);
      arr = imgData.data;
      if (minval === undefined)
        min = this.scaledArcsinh(this.minimum);
      else
        min = this.scaledArcsinh(minval);
      max = this.scaledArcsinh(this.maximum);
      range = max - min;
      length = arr.length;
      while (length -= 4) {
        pixel = this.scaledArcsinh(data[length / 4] / this.rescaling);
        value = 255 * (pixel - min) / range;
        arr[length + 0] = value;
        arr[length + 1] = value;
        arr[length + 2] = value;
        arr[length + 3] = 255;
      }
      // Add the mask to the array
      if (this.showMask && this.nImages % 2 == 0)
        this.addMask(arr);

      // Flip the vertical orientation of the image
      this.flipYAxis(arr, 4*width, height);

      imgData.data = arr;
      this.ctx.putImageData(imgData, 0, 0);
      // This is a post-draw flip option
      //this.flipCanvas();

      return this._applyTransforms();
    };
    
    Api.prototype.drawPeter = function() {
      return this.drawAsinh(1);
    };
    
    Api.prototype.teardown = function() {
      // document.write("teardown,");
      this.el.removeChild(this.canvas);
      this.ctx = void 0;
      return this._reset();
    };

    Api.prototype.arcsinh = function(value) {
      return Math.log(value + Math.sqrt(1 + value * value));
    };

    Api.prototype.scaledArcsinh = function(value) {
      return this.arcsinh(value / -0.033) / this.arcsinh(1.0 / -0.033);
    };

    return Api;

  })(BaseApi);

  version = this.astro.WebFITS.version;

  this.astro.WebFITS = Api;

  this.astro.WebFITS.version = version;

}).call(this);
